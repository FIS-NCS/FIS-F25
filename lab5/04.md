# Buffer Overflow: Exercise

Consider a similar code to the previous practice.

```c
#include <stdio.h>
#include <stdlib.h>

void vuln() {
    char buffer[256];
    gets(buffer);
}

int main() {
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stdin, NULL, _IONBF, 0);

    puts("Guess my name");
    vuln();
    puts("Wrong!");

    return 0;
}
```

## Exercise 3

This time, there is no `win` function to jump to, but we can use our own [shellcode](http://shell-storm.org/shellcode/files/shellcode-811.html) and jump to it.

1. Install needed dependency

    ```bash
    sudo apt install gcc-multilib
    ```

1. A precompiled 32-bit binary of the above code is also provided, compiled with the same options to make exploitation possible.

    ```bash
    wget http://renderer:10082/workshop/content/task
    sudo chmod +x ./task
    ./task
    ```

1. Use the same method with `cyclic` to understand padding length (`L`).

1. Construct your payload in the following form, such that `RET_ADDR` jumps somewhere in the `NOP_SLED`, and that the total length of payload (without `RET_ADDR`) equals `L`.

    ```text
    [NOP_SLED][SHELLCODE][NOP_SEQUENCE][RET_ADDR]
    ```

    > The `NOP_SEQUENCE` after the `SHLLCODE` ensures a margin between ESP and the shellcode, so push instructions won't corrupt it during its execution.

1. Supply the payload to the program to gain a shell, verify it works by running some command like `whoami` or `id`.

## Common issues

- [ASLR](https://en.wikipedia.org/wiki/Address_space_layout_randomization) randomly arranges the address space positions of key data areas, including the stack. Command to disable ASLR on the host (make sure you re-enable it later by setting a value of `1` or `2`).

    ```bash
    echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
    ```

- It's possible to have the exploit only working in GDB but not outside it because  [[ref.](https://stackoverflow.com/questions/17775186/buffer-overflow-works-in-gdb-but-not-without-it)] OS places environment variables and program arguments *before* the start address of the stack, shifting the addresses and thus requiring different payloads to run a successful exploit. Possible solutions:
  - Run the binary with no env vars like: `env - ./binary`
  - For gdb: `gdb -ex "unset env" ./binary`

## Bonus Exercise

Crack the same binary to obtain a shell using a [return-to-libc](https://en.wikipedia.org/wiki/Return-to-libc_attack) attack (i.e., without directly injecting a shellcode in the buffer).
