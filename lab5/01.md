# Executable and Linkable Format (ELF)

> Reading: <https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/>

**Goal**: to explore the executable file generated by `gcc` when compiling a C source code.

## Practice

1. Create `main.c`

    ```c
    #include <stdio.h>

    int square(int x) {
        return x * x;
    }

    int main() {
        printf("%d", square(3));
        return 0;
    }
    ```

2. Compile and the program

    ```bash
    gcc -g main.c
    ./a.out
    ```

## Exercise 1

1. Use `file` and `readelf -h` to obtain information about the resulting `a.out` and answer the questions, showing the relevant output:
    - Would this binary work regardless of the memory location where it gets loaded in runtime?
    - Is debugging information included in the binary?
    - Is needed library code (e.g., `printf` code) included in the binary?
    - Will memory addressing within the binary use big-endian or little-endian.

1. List dynamic dependencies of the binary with `ldd`
    - Where did the linker find the required C library files?

1. Run the binary with `ltrace`.
    - What was the value for the instruction pointer at the moment when `printf` is called?

1. Run the binary with `strace`.
    - What is the purpose of the multiple `mmap` calls?
    - Show the `syscall` that was used to print the program output?

1. Use `objdump` to list the sections in the binary
    - How many sections did you find in the binary?
    - Briefly explain the purpose of key sections: `.text`, `.data`, `.bss`, `.rodata`, `.got`, `.plt`?
