# Hash-based Authentication

1. It's probably better to store password hashes in a database instead of plaintext passwords in code. Create `init_db.py` to intitialize a SQLite database following this method.

   ```python
   import sqlite3

   if __name__ == '__main__':
      open('db.sqlite','w').close()
      conn = sqlite3.connect('db.sqlite')
      conn.execute('CREATE TABLE Users(name TEXT, pass_hash TEXT)')
      conn.execute(f'INSERT INTO Users(name, pass_hash) VALUES("admin", "345301f693deda839f7ed280a4b30763")')
      conn.commit()
      conn.close()
   ```

   ```bash
   python3 init_db.py 
   ```

2. Modify `app.py` to read values from the db.

   ```python
   from flask import Flask
   from flask_httpauth import HTTPBasicAuth
   from hashlib import md5
   from sqlite3 import connect

   app = Flask(__name__)
   auth = HTTPBasicAuth(app)
   conn = connect('db.sqlite')
   users = {
      "admin": conn.execute('SELECT pass_hash FROM Users WHERE name="admin"').fetchone()[0]
   }

   @auth.verify_password
   def verify_password(username, password):
      if username in users and md5(password.encode()).hexdigest() == users[username]:
         return username

   @app.route('/')
   @auth.login_required
   def home():
      return f'<h1>Hello, {auth.current_user()}</h1>'

   if __name__ == '__main__':
      app.run()
   ```

## Exercise 3

1. Use reverse hash lookup websites (rainbow tables) to get the admin password and use it to login with `curl`.
2. Update the code to keep the password trivial but prevent reverse hash lookups (explain why your security fix works).
